function renderWord() {
    const phase = phases[currentPhase];
    const word = phase.content[currentIndex];
    phaseContentDiv.innerHTML = "";
    phaseContentDiv.style.display = "block";

    // Phase 2: Audio playback, recording, and enabling Next Word after stop
    if (phase.audio) {
        const audio = document.createElement("audio");
        const audioPath = `${versionPaths[randomVersion]}/${word}.mp3`;
        audio.src = audioPath;
        audio.controls = true;
        audio.preload = "auto"; // Ensures audio preloading

        phaseContentDiv.appendChild(audio);

        // Hide "Next Word" button until audio finishes and recording is stopped
        nextWordButton.style.display = "none";
        nextWordButton.disabled = true;

        audio.oncanplaythrough = () => {
            audio.play(); // Start playback once the audio can play through
        };

        audio.onended = () => {
            // Don't show Next Word until recording is stopped
            if (mediaRecorder && mediaRecorder.state === "inactive") {
                nextWordButton.style.display = "block";
                nextWordButton.disabled = false; // Enable the Next Word button after audio ends
            }
        };

        // Add recording button only once when audio starts playing
        if (!document.getElementById("record-button")) {
            const recordButton = document.createElement("button");
            recordButton.id = "record-button";  // Set an ID to identify the button
            recordButton.textContent = "Start Recording";
            recordButton.onclick = () => toggleRecording(word, recordButton);
            phaseContentDiv.appendChild(recordButton);
        }
    }
    // Handle Phase 1: Display word and recording button
    else if (phase.record) {
        const wordDiv = document.createElement("div");
        wordDiv.className = "word";
        wordDiv.textContent = word;
        phaseContentDiv.appendChild(wordDiv);

        const recordButton = document.createElement("button");
        recordButton.textContent = "Start Recording";
        recordButton.onclick = () => toggleRecording(word, recordButton);
        phaseContentDiv.appendChild(recordButton);
    }
    // Handle Phase 3: Display yes/no buttons
    else if (phase.test) {
        const wordDiv = document.createElement("div");
        wordDiv.className = "word";
        wordDiv.textContent = word;
        phaseContentDiv.appendChild(wordDiv);

        const yesButton = document.createElement("button");
        yesButton.textContent = "Yes";
        yesButton.onclick = nextWord;
        yesButton.onclick = () => { 
            responses.push({ word, correct: phase.content.includes(word) }); 
            nextWord(); 
        };

        const noButton = document.createElement("button");
        noButton.textContent = "No";
        noButton.onclick = nextWord;
        noButton.onclick = () => { 
            responses.push({ word, correct: !phase.content.includes(word) }); 
            nextWord(); 
        };

        phaseContentDiv.appendChild(yesButton);
        phaseContentDiv.appendChild(noButton);
    }

    // Hide "Next Word" button until task completion
    nextWordButton.style.display = "none";
    nextWordButton.disabled = true;
}

function toggleRecording(word, button) {
    if (mediaRecorder) {
        if (mediaRecorder.state === "inactive") {
            audioChunks = [];
            mediaRecorder.ondataavailable = event => audioChunks.push(event.data);

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/mpeg' });
                const respondentId = getRespondentId();  // Use this one instead of redeclaring

                // Build folder path using survey data
                const { grade, "preferred-accent": accent, gender, "learning-start": startAge, languages, dialects } = surveyData;
                const folderPath = `${grade}_${accent}_${gender}_${startAge}_${languages}_${dialects}/`;

                const phaseFolder = `phase${currentPhase + 1}`;  // e.g., phase1, phase2
                const versionFolder = `v${randomVersion}`; // v1, v2, v3, v4
                const fileName = `${respondentId}/${folderPath}${phaseFolder}/${versionFolder}/${word}_${Date.now()}.mp3`;

                const client = new OSS({
                    region: 'oss-rg-china-mainland',
                    accessKeyId: 'LTAI5tMVY9Jpm2MroinSie5z',
                    accessKeySecret: 'BU384EPr4lgFxnBEgwx041JaqSFts6',
                    bucket: 'linguisticstest',
                });

                try {
                    const result = await client.put(fileName, audioBlob);
                    console.log(`Uploaded successfully: ${result.url}`);
                    button.textContent = "Recording Submitted";
                    nextWordButton.style.display = "block";
                    nextWordButton.disabled = false;
                } catch (err) {
                    console.error('Upload failed:', err);
                }
            };
            mediaRecorder.start();
            button.textContent = "Stop Recording";
        } else {
            mediaRecorder.stop();
            button.textContent = "Recording Stopped";
        }
    }
}
